<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
    <id>https://https://github.com/IdeasYH/IdeasYH.github.io</id>
    <title>Gridea</title>
    <updated>2020-10-24T09:03:35.657Z</updated>
    <generator>https://github.com/jpmonette/feed</generator>
    <link rel="alternate" href="https://https://github.com/IdeasYH/IdeasYH.github.io"/>
    <link rel="self" href="https://https://github.com/IdeasYH/IdeasYH.github.io/atom.xml"/>
    <subtitle>温故而知新</subtitle>
    <logo>https://https://github.com/IdeasYH/IdeasYH.github.io/images/avatar.png</logo>
    <icon>https://https://github.com/IdeasYH/IdeasYH.github.io/favicon.ico</icon>
    <rights>All rights reserved 2020, Gridea</rights>
    <entry>
        <title type="html"><![CDATA[Springboot源码学习_启动类]]></title>
        <id>https://https://github.com/IdeasYH/IdeasYH.github.io/post/springboot-yuan-ma-xue-xi-_-qi-dong-lei/</id>
        <link href="https://https://github.com/IdeasYH/IdeasYH.github.io/post/springboot-yuan-ma-xue-xi-_-qi-dong-lei/">
        </link>
        <updated>2020-10-24T02:40:02.000Z</updated>
        <content type="html"><![CDATA[<h1 id="关于启动类jarluncher">关于启动类jarLuncher</h1>
<h5 id="概述">概述</h5>
<p>SpringBoot生成的jar包</p>
<p>​	当使用java -jar命令执行Spring Boot应用的可执行jar文件时，该命令引导标准可执行的jar文件，通过在jar中<code>MANIFES.MF</code>找到<code>Main-Class</code>，以<code>JarLauncher.java</code>为入口，加载所有的需要的启动资源（<code>BOOT-INF/classes/*，BOOT-INF/lib/*</code>），交给自定义的类加载器，然后通过反射，启动<code>MANIFES.MF</code>中定义的<code>Start-Class</code>的<code>main()</code>方法，即应用启动类的<code>main()</code>方法。</p>
<p>​	SpringBoot 的可执行jar包又称fat jar ，是包含所有依赖的 jar 包，jar 包中嵌入了除 java 虚拟机以外的所有依赖，是一个 all-in-one jar 包。普通插件maven-jar-plugin生成的包和spring-boot-maven-plugin生成的包之间的直接区别，是fat jar中主要增加了两部分，第一部分是lib目录，存放的是Maven依赖的jar包文件,第二部分是spring boot loader相关的类。</p>
<p>​	<font color = "ff0000">但是系统自带的AppClassLoarder不支持读取嵌套jar包,引入自定义类加载器就是为了能解决jar包嵌套jar包的问题,于是springboot将自定义的类加载器放在最顶成目录,使它可以被加载.</font></p>
<img src="C:\Users\idea\AppData\Roaming\Typora\typora-user-images\image-20201024110331302.png" alt="image-20201024110331302" style="zoom: 67%;" />
<h5 id="为什么springboot要将loader-类下的所有文件复制出来呢">为什么SpringBoot要将Loader 类下的所有文件复制出来呢</h5>
<p>如果将SpringBoot Class Loader 也放到lib文件下，是根本无法被加载到的，因为它根本不符合jar文件的一个标准规范.</p>
<p>程序要有一个启动入口，这个入口要由应用类加载器加载，先将SpringBoot Class Loader加载到内存中，然后通过后续的一些操作创建线程上下文加载器，去加载第三方jar。</p>
<h2 id="1-maven">1 Maven</h2>
<p>也就是说想要知道<code>fat jar</code>是如何生成的，就必须知道<code>spring-boot-maven-plugin</code>工作机制，而<code>spring-boot-maven-plugin</code>属于自定义插件，因此我们又必须知道，<strong>Maven的自定义插件是如何工作的</strong></p>
<h5 id="maven的自定义插件">Maven的自定义插件</h5>
<p>Maven 拥有三套相互独立的生命周期: <strong>clean</strong>、<strong>default</strong> 和 <strong>site</strong>, 而每个生命周期包含一些<strong>phase</strong>阶段, 阶段是有顺序的, 并且后面的阶段依赖于前面的阶段。生命周期的阶段<strong>phase</strong>与插件的目标<strong>goal</strong>相互绑定，用以完成实际的构建任务。</p>
<pre><code class="language-xml">&lt;plugin&gt;
    &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt;
    &lt;artifactId&gt;spring-boot-maven-plugin&lt;/artifactId&gt;
    &lt;executions&gt;
        &lt;execution&gt;
            &lt;goals&gt;
                &lt;goal&gt;repackage&lt;/goal&gt;
            &lt;/goals&gt;
        &lt;/execution&gt;
    &lt;/executions&gt;
&lt;/plugin&gt;
</code></pre>
<p><code>repackage</code>目标对应的将执行到<code>org.springframework.boot.maven.RepackageMojo#execute</code>，该方法的主要逻辑是调用了<code>org.springframework.boot.maven.RepackageMojo#repackage</code></p>
<pre><code class="language-Java">private void repackage() throws MojoExecutionException {
     //获取使用maven-jar-plugin生成的jar，最终的命名将加上.orignal后缀
   Artifact source = getSourceArtifact();
    //最终文件，即Fat jar
   File target = getTargetFile();
    //获取重新打包器，将重新打包成可执行jar文件
   Repackager repackager = getRepackager(source.getFile());
    //查找并过滤项目运行时依赖的jar
   Set&lt;Artifact&gt; artifacts = filterDependencies(this.project.getArtifacts(),
         getFilters(getAdditionalFilters()));
    //将artifacts转换成libraries
   Libraries libraries = new ArtifactsLibraries(artifacts, this.requiresUnpack,
         getLog());
   try {
       //提供Spring Boot启动脚本
      LaunchScript launchScript = getLaunchScript();
       //执行重新打包逻辑，生成最后fat jar
      repackager.repackage(target, libraries, launchScript);
   }
   catch (IOException ex) {
      throw new MojoExecutionException(ex.getMessage(), ex);
   }
    //将source更新成 xxx.jar.orignal文件
   updateArtifact(source, target, repackager.getBackupFile());
}
</code></pre>
<p>我们关心一下<code>org.springframework.boot.maven.RepackageMojo#getRepackager</code>这个方法，知道<code>Repackager</code>是如何生成的，也就大致能够推测出内在的打包逻辑。</p>
<pre><code class="language-Java">private Repackager getRepackager(File source) {
   Repackager repackager = new Repackager(source, this.layoutFactory);
   repackager.addMainClassTimeoutWarningListener(
         new LoggingMainClassTimeoutWarningListener());
    //设置main class的名称，如果不指定的话则会查找第一个包含main方法的类，repacke最后将会设置org.springframework.boot.loader.JarLauncher
   repackager.setMainClass(this.mainClass);
   if (this.layout != null) {
      getLog().info(&quot;Layout: &quot; + this.layout);
       //重点关心下layout 最终返回了 org.springframework.boot.loader.tools.Layouts.Jar
      repackager.setLayout(this.layout.layout());
   }
   return repackager;
}
/**
 * Executable JAR layout.
 */
public static class Jar implements RepackagingLayout {
   @Override
   public String getLauncherClassName() {
      return &quot;org.springframework.boot.loader.JarLauncher&quot;;
   }
   @Override
   public String getLibraryDestination(String libraryName, LibraryScope scope) {
      return &quot;BOOT-INF/lib/&quot;;
   }
   @Override
   public String getClassesLocation() {
      return &quot;&quot;;
   }
   @Override
   public String getRepackagedClassesLocation() {
      return &quot;BOOT-INF/classes/&quot;;
   }
   @Override
   public boolean isExecutable() {
      return true;
   }
}
</code></pre>
<p><code>layout</code>我们可以将之翻译为文件布局，或者目录布局，代码一看清晰明了，同时我们需要关注，也是下一个重点关注对象<code>org.springframework.boot.loader.JarLauncher</code>，从名字推断，这很可能是返回可执行<code>jar</code>文件的启动类。</p>
<h5 id="manifestmf文件内容">MANIFEST.MF文件内容</h5>
<pre><code class="language-json">Manifest-Version: 1.0
Start-Class: com.shengsiyuan.boot.MyApplication
Main-Class: org.springframework.boot.loader.JarLauncher
</code></pre>
<p><code>repackager</code>生成的MANIFEST.MF文件为以上信息，可以看到两个关键信息<code>Main-Class</code>和<code>Start-Class</code>。我们可以进一步，程序的启动入口并不是我们SpringBoot中定义的<code>main</code>，而是<code>JarLauncher#main</code>，而再在其中利用反射调用定义好的<code>Start-Class</code>的<code>main</code>方法</p>
<h5 id="jarlauncher">JarLauncher</h5>
<h5 id="重点类介绍">重点类介绍</h5>
<ul>
<li>
<p><code>java.util.jar.JarFile</code> JDK工具类提供的读取<code>jar</code>文件</p>
</li>
<li>
<p><code>org.springframework.boot.loader.jar.JarFile</code>Springboot-loader 继承JDK提供<code>JarFile</code>类</p>
</li>
<li>
<p><code>java.util.jar.JarEntry</code>DK工具类提供的``jar```文件条目</p>
</li>
<li>
<p><code>org.springframework.boot.loader.jar.JarEntry</code> Springboot-loader 继承JDK提供<code>JarEntry</code>类</p>
</li>
<li>
<pre><code>org.springframework.boot.loader.archive.Archive
</code></pre>
<p>Springboot抽象出来的统一访问资源的层</p>
<ul>
<li><code>JarFileArchive</code>jar包文件的抽象</li>
<li><code>ExplodedArchive</code>文件目录</li>
</ul>
</li>
</ul>
<p>这里重点描述一下<code>JarFile</code>的作用，每个<code>JarFileArchive</code>都会对应一个<code>JarFile</code>。在构造的时候会解析内部结构，去获取<code>jar</code>包里的各个<strong>文件</strong>或<strong>文件夹</strong>类。我们可以看一下该类的注释。</p>
<pre><code>/* Extended variant of {@link java.util.jar.JarFile} that behaves in the same way but
* offers the following additional functionality.
* &lt;ul&gt;
* &lt;li&gt;A nested {@link JarFile} can be {@link #getNestedJarFile(ZipEntry) obtained} based
* on any directory entry.&lt;/li&gt;
* &lt;li&gt;A nested {@link JarFile} can be {@link #getNestedJarFile(ZipEntry) obtained} for
* embedded JAR files (as long as their entry is not compressed).&lt;/li&gt;
**/ &lt;/ul&gt;
</code></pre>
<p><code>jar</code>里的资源分隔符是<code>!/</code>，在JDK提供的<code>JarFile</code> URL只支持一个’!/‘，而Spring boot扩展了这个协议，让它支持多个’!/‘，就可以表示jar in jar、jar in directory、fat jar的资源了。</p>
<h5 id="自定义类加载机制">自定义类加载机制</h5>
<ul>
<li>最基础：Bootstrap ClassLoader（加载JDK的/lib目录下的类）</li>
<li>次基础：Extension ClassLoader（加载JDK的/lib/ext目录下的类）</li>
<li>普通：Application ClassLoader（程序自己classpath下的类）</li>
</ul>
<p>首先需要关注<strong>双亲委派机制</strong>很重要的一点是，如果一个类可以被委派最基础的ClassLoader加载，就不能让高层的ClassLoader加载，这样是为了范围错误的引入了非JDK下但是类名一样的类。其二，如果在这个机制下，由于<code>fat jar</code>中依赖的各个<code>jar</code>文件，并不在程序自己<code>classpath</code>下，也就是说，如果我们采用双亲委派机制的话，<strong>根本获取不到我们所依赖的jar包，因此我们需要修改双亲委派机制的查找class的方法，自定义类加载机制</strong>。</p>
<p>先简单的介绍Springboot2中<code>LaunchedURLClassLoader</code>，该类继承了<code>java.net.URLClassLoader</code>,重写了<code>java.lang.ClassLoader#loadClass(java.lang.String, boolean)</code>，然后我们再探讨他是如何修改双亲委派机制。</p>
<p>在上面我们讲到Spring boot支持多个’!/‘以表示多个jar，而我们的问题在于，如何解决查找到这多个jar包。我们看一下<code>LaunchedURLClassLoader</code>的构造方法。</p>
<pre><code class="language-Java">public LaunchedURLClassLoader(URL[] urls, ClassLoader parent) {
   super(urls, parent);
}
</code></pre>
<p><strong><code>urls</code>注释解释道<code>the URLs from which to load classes and resources</code>，即fat jar包依赖的所有类和资源，将该<code>urls</code>参数传递给父类<code>java.net.URLClassLoader</code>，由父类的<code>java.net.URLClassLoader#findClass</code>执行查找类方法，该类的查找来源即构造方法传递进来的urls参数</strong></p>
<pre><code class="language-Java">//LaunchedURLClassLoader的实现
protected Class&lt;?&gt; loadClass(String name, boolean resolve)
      throws ClassNotFoundException {
   Handler.setUseFastConnectionExceptions(true);
   try {
      try {
          //尝试根据类名去定义类所在的包，即java.lang.Package，确保jar in jar里匹配的manifest能够和关联	           //的package关联起来
         definePackageIfNecessary(name);
      }
      catch (IllegalArgumentException ex) {
         // Tolerate race condition due to being parallel capable
         if (getPackage(name) == null) {
            // This should never happen as the IllegalArgumentException indicates
            // that the package has already been defined and, therefore,
            // getPackage(name) should not return null.
             
            //这里异常表明，definePackageIfNecessary方法的作用实际上是预先过滤掉查找不到的包
            throw new AssertionError(&quot;Package &quot; + name + &quot; has already been &quot;
                  + &quot;defined but it could not be found&quot;);
         }
      }
      return super.loadClass(name, resolve);
   }
   finally {
      Handler.setUseFastConnectionExceptions(false);
   }
}
</code></pre>
<p>方法<code>super.loadClass(name, resolve)</code>实际上会回到了<code>java.lang.ClassLoader#loadClass(java.lang.String, boolean)</code>，遵循双亲委派机制进行查找类，而<code>Bootstrap ClassLoader</code>和<code>Extension ClassLoader</code>将会查找不到fat jar依赖的类，最终会来到<code>Application ClassLoader</code>，调用<code>java.net.URLClassLoader#findClass</code></p>
<h5 id="如何真正的启动">如何真正的启动</h5>
<p>Springboot2和Springboot1的最大区别在于，Springboo1会新起一个线程，来执行相应的<strong>反射调用逻辑</strong>，而SpringBoot2则去掉了构建新的线程这一步。方法是<code>org.springframework.boot.loader.Launcher#launch(java.lang.String[], java.lang.String, java.lang.ClassLoader)</code>反射调用逻辑比较简单，这里就不再分析，比较关键的一点是，在调用<code>main</code>方法之前，将当前线程的上下文类加载器设置成<code>LaunchedURLClassLoader</code></p>
<pre><code class="language-Java">protected void launch(String[] args, String mainClass, ClassLoader classLoader)
      throws Exception {
   Thread.currentThread().setContextClassLoader(classLoader);
   createMainMethodRunner(mainClass, args, classLoader).run();
}
</code></pre>
<h5 id="demo">Demo</h5>
<pre><code class="language-Java">public static void main(String[] args) throws ClassNotFoundException, MalformedURLException {
        JarFile.registerUrlProtocolHandler();
// 构造LaunchedURLClassLoader类加载器，这里使用了2个URL，分别对应jar包中依赖包spring-boot-loader和spring-boot，使用 &quot;!/&quot; 分开，需要org.springframework.boot.loader.jar.Handler处理器处理
        LaunchedURLClassLoader classLoader = new LaunchedURLClassLoader(
                new URL[] {
                        new URL(&quot;jar:file:/E:/IdeaProjects/oneday-auth/oneday-auth-server/target/oneday-auth-server-1.0.0-SNAPSHOT.jar!/BOOT-INF/lib/spring-boot-loader-1.2.3.RELEASE.jar!/&quot;)
                        , new URL(&quot;jar:file:/E:/IdeaProjects/oneday-auth/oneday-auth-server/target/oneday-auth-server-1.0.0-SNAPSHOT.jar!/BOOT-INF/lib/spring-boot-2.1.3.RELEASE.jar!/&quot;)
                },
                Application.class.getClassLoader());
// 加载类
// 这2个类都会在第二步本地查找中被找出(URLClassLoader的findClass方法)
        classLoader.loadClass(&quot;org.springframework.boot.loader.JarLauncher&quot;);
        classLoader.loadClass(&quot;org.springframework.boot.SpringApplication&quot;);
// 在第三步使用默认的加载顺序在ApplicationClassLoader中被找出
   classLoader.loadClass(&quot;org.springframework.boot.autoconfigure.web.DispatcherServletAutoConfiguration&quot;);

//        SpringApplication.run(Application.class, args);
    }
</code></pre>
<h2 id="2启动器实现原理">2启动器实现原理</h2>
<p>Launcher的继承关系如下：<br>
<img src="C:\Users\idea\AppData\Roaming\Typora\typora-user-images\image-20201024114850040.png" alt="image-20201024114850040" style="zoom:67%;" /></p>
<h3 id="启动类jarlauncher"><strong>启动类：JarLauncher</strong></h3>
<pre><code class="language-java">//JarLauncher.java
public class JarLauncher extends ExecutableArchiveLauncher {

	static final String BOOT_INF_CLASSES = &quot;BOOT-INF/classes/&quot;;

	static final String BOOT_INF_LIB = &quot;BOOT-INF/lib/&quot;;

	public JarLauncher() {
	}

	protected JarLauncher(Archive archive) {
		super(archive);
	}

	@Override
	protected boolean isNestedArchive(Archive.Entry entry) {
		if (entry.isDirectory()) {
			return entry.getName().equals(BOOT_INF_CLASSES);
		}
		return entry.getName().startsWith(BOOT_INF_LIB);
	}

	public static void main(String[] args) throws Exception {
		new JarLauncher().launch(args);
	}
}
</code></pre>
<p>JarLauncher默认构造函数实现为空，它父类ExecutableArchiveLauncher会调用再上一级父类Launcher的createArchive方法加载jar包, 加载了jar包之后，我们就能获取到里面所有的资源。</p>
<pre><code class="language-java">	//JarLauncher.java
	
	//JarLauncher默认构造函数
	public JarLauncher() {
	}
	
//ExecutableArchiveLauncher.java	

public ExecutableArchiveLauncher() {
		try {
      //开始加载jar包
			this.archive = createArchive();
		}
		catch (Exception ex) {
			throw new IllegalStateException(ex);
		}
	}
//Launcher.java	

protected final Archive createArchive() throws Exception {
    //通过获取当前Class类的信息，查找到当前归档文件的路径
		ProtectionDomain protectionDomain = getClass().getProtectionDomain();
		CodeSource codeSource = protectionDomain.getCodeSource();
		URI location = (codeSource != null) ? codeSource.getLocation().toURI() : null;
		String path = (location != null) ? location.getSchemeSpecificPart() : null;
		if (path == null) {
			throw new IllegalStateException(&quot;Unable to determine code source archive&quot;);
		}
    //获取到路径之后，创建对应的文件，并检查是否存在
		File root = new File(path);
		if (!root.exists()) {
			throw new IllegalStateException(
					&quot;Unable to determine code source archive from &quot; + root);
		}
    //如果是目录，则创建ExplodedArchive，否则创建JarFileArchive
		return (root.isDirectory() ? new ExplodedArchive(root)
				: new JarFileArchive(root));
	}
</code></pre>
<h3 id="核心方法launchstring-args">核心方法：launch(String[] args)</h3>
<p>launch方法实际上是调用父类Launcher的launch方法</p>
<pre><code class="language-java">// Launcher.java	

protected void launch(String[] args) throws Exception {
    //注册 Spring Boot 自定义的 URLStreamHandler 实现类，用于 jar 包的加载读取, 可读取到内嵌的jar包
		JarFile.registerUrlProtocolHandler();
    //创建自定义的 ClassLoader 实现类，用于从 jar 包中加载类。
		ClassLoader classLoader = createClassLoader(getClassPathArchives());
    //执行我们声明的 Spring Boot 启动类，进行 Spring Boot 应用的启动。
		launch(args, getMainClass(), classLoader);
	}
</code></pre>
<p>简单来说，就是创建一个可以读取 <code>jar</code> 包中类的加载器，保证 <code>BOOT-INF/lib</code> 目录下的类和 <code>BOOT-classes</code> 内嵌的 <code>jar</code> 中的类能够被正常加载到，之后执行 Spring Boot 应用的启动。</p>
<h4 id="方法一registerurlprotocolhandler">方法一：<strong>registerUrlProtocolHandler</strong></h4>
<pre><code class="language-java">public static void registerUrlProtocolHandler() {
    	// 获得 URLStreamHandler 的路径
		String handlers = System.getProperty(PROTOCOL_HANDLER, &quot;&quot;);
    	// 将 Spring Boot 自定义的 HANDLERS_PACKAGE(org.springframework.boot.loader) 补充上去
		System.setProperty(PROTOCOL_HANDLER, (&quot;&quot;.equals(handlers) ? HANDLERS_PACKAGE
				: handlers + &quot;|&quot; + HANDLERS_PACKAGE));
    	// 重置已缓存的 URLStreamHandler 处理器们
		resetCachedUrlHandlers();
	}
</code></pre>
<p>该方法的目的就是通过将 <code>org.springframework.boot.loader</code> 包设置到 <code>&quot;java.protocol.handler.pkgs&quot;</code> 环境变量，从而使用到自定义的 URLStreamHandler 实现类 Handler，处理 <code>jar:</code> 协议的 URL。</p>
<pre><code>利用java url协议实现扩展原理，自定义jar协议
将org.springframework.boot.loader包 追加到java系统 属性java.protocol.handler.pkgs中，实现自定义jar协议

java会在java.protocol.handler.pkgs系统属性指定的包中查找与协议同名的子包和名为Handler的类，
即负责处理当前协议的URLStreamHandler实现类必须在 &lt;包名&gt;.&lt;协议名定义的包&gt; 中，并且类名称必须为Handler
例如：
org.springframework.boot.loader.jar.Handler这个类 将用于处理jar协议

这个jar协议实现作用：
默认情况下，JDK提供的ClassLoader只能识别jar中的class文件以及加载classpath下的其他jar包中的class文件。
对于jar包中的jar包是无法加载的
所以spring boot 自己定义了一套URLStreamHandler实现类和JarURLConnection实现类，用来加载jar包中的jar包的class类文件
</code></pre>
<p>举个例子：</p>
<pre><code>jar:file:C:/Users/Administrator/Desktop/demo/demo/target/jarlauncher-0.0.1-SNAPSHOT.jar!/lib/spring-boot-1.5.10.RELEASE.jar!/

jar:file:C:/Users/Administrator/Desktop/demo/demo/target/jarlauncher-0.0.1-SNAPSHOT.jar!/lib/spring-boot-1.5.10.RELEASE.jar!/org/springframework/boot/loader/JarLauncher.class
123
</code></pre>
<p>我们看到如果有 jar 包中包含 jar，或者 jar 包中包含 jar 包里面的 class 文件，那么会使用 !/分隔开，这种方式只有 org.springframework.boot.loader.jar.Handler 能处理，它是 SpringBoot 内部扩展出来一种<strong>URL协议</strong>.</p>
<p>通常，jar里的资源分隔符是!/，在JDK提供的JarFile URL只支持一层“!/”，而Spring Boot扩展了该协议，可支持多层“!/”。</p>
<h4 id="方法二createclassloader">方法二：<strong>createClassLoader</strong></h4>
<pre><code class="language-java">ClassLoader classLoader = createClassLoader(getClassPathArchives());
</code></pre>
<h5 id="getclasspatharchives">getClassPathArchives（）</h5>
<pre><code class="language-java">// ExecutableArchiveLauncher.java

@Override
protected List&lt;Archive&gt; getClassPathArchives() throws Exception {
 // &lt;1&gt; 获得所有 Archive
 List&lt;Archive&gt; archives = new ArrayList&lt;&gt;(
   this.archive.getNestedArchives(this::isNestedArchive));
 // &lt;2&gt; 后续处理：是个空方法
 postProcessClassPathArchives(archives);
 return archives;
}
</code></pre>
<p><code>&lt;1&gt;</code> 处，<code>this::isNestedArchive</code> 代码段，创建了 EntryFilter 匿名实现类，用于过滤 <code>jar</code> 包不需要的目录。目的就是过滤获得，<code>BOOT-INF/classes/</code> 目录下的类，以及 <code>BOOT-INF/lib/</code> 的内嵌 <code>jar</code> 包。</p>
<pre><code class="language-java">// JarLauncher.java

static final String BOOT_INF_CLASSES = &quot;BOOT-INF/classes/&quot;;

static final String BOOT_INF_LIB = &quot;BOOT-INF/lib/&quot;;

@Override
protected boolean isNestedArchive(Archive.Entry entry) {
    // 如果是目录的情况，只要 BOOT-INF/classes/ 目录
 if (entry.isDirectory()) {
  return entry.getName().equals(BOOT_INF_CLASSES);
 }
 // 如果是文件的情况，只要 BOOT-INF/lib/ 目录下的 `jar` 包
 return entry.getName().startsWith(BOOT_INF_LIB);
}
</code></pre>
<p>&lt;1&gt;处getNestedArchives()方法实现</p>
<pre><code class="language-java">	//JarFileArchive.java
	
	@Override
	public List&lt;Archive&gt; getNestedArchives(EntryFilter filter) throws IOException {
		List&lt;Archive&gt; nestedArchives = new ArrayList&lt;&gt;();
		for (Entry entry : this) {
			if (filter.matches(entry)) {
				nestedArchives.add(getNestedArchive(entry));
			}
		}
		return Collections.unmodifiableList(nestedArchives);
	}
</code></pre>
<h5 id="createclassloaderlist-archives">createClassLoader(List archives)</h5>
<pre><code class="language-java">// ExecutableArchiveLauncher.java

protected ClassLoader createClassLoader(List&lt;Archive&gt; archives) throws Exception {
 // 获得所有 Archive 的 URL 地址
    List&lt;URL&gt; urls = new ArrayList&lt;&gt;(archives.size());
 for (Archive archive : archives) {
  urls.add(archive.getUrl());
 }
 // 创建加载这些 URL 的 ClassLoader
 return createClassLoader(urls.toArray(new URL[0]));
}

protected ClassLoader createClassLoader(URL[] urls) throws Exception {
 return new LaunchedURLClassLoader(urls, getClass().getClassLoader());
}
</code></pre>
<p>基于获得的 Archive 数组，创建自定义 ClassLoader 实现类 LaunchedURLClassLoader，通过它来加载 <code>BOOT-INF/classes</code> 目录下的类，以及 <code>BOOT-INF/lib</code> 目录下的 <code>jar</code> 包中的类。</p>
<h4 id="方法三launchstring-args-string-mainclass-classloader-classloader">方法三：launch(String[] args, String mainClass, ClassLoader classLoader)</h4>
<p>给定存档文件和完全配置的类加载器，启动应用程序。</p>
<pre><code class="language-java">launch(args, getMainClass(), classLoader);
protected void launch(String[] args, String mainClass, ClassLoader classLoader)
			throws Exception {
    	  // &lt;1&gt; 设置 LaunchedURLClassLoader 作为类加载器
		Thread.currentThread().setContextClassLoader(classLoader);
    	 // &lt;2&gt; 创建 MainMethodRunner 对象，并执行 run 方法，启动 Spring Boot 应用
		createMainMethodRunner(mainClass, args, classLoader).run();
	}
</code></pre>
<p><code>&lt;1&gt;</code> 处：设置 LaunchedURLClassLoader 作为类加载器，从而保证能够从 <code>jar</code> 包中加载到相应的类。</p>
<h5 id="getmainclass"><strong>getMainClass()</strong></h5>
<pre><code class="language-java">// ExecutableArchiveLauncher.java

@Override
protected String getMainClass() throws Exception {
    // 获得启动的类的全名
 Manifest manifest = this.archive.getManifest();
 String mainClass = null;
 if (manifest != null) {
  mainClass = manifest.getMainAttributes().getValue(&quot;Start-Class&quot;);
 }
 if (mainClass == null) {
  throw new IllegalStateException(
    &quot;No 'Start-Class' manifest entry specified in &quot; + this);
 }
 return mainClass;
}
</code></pre>
<p>从 <code>jar</code> 包的 <code>MANIFEST.MF</code> 文件的 <code>Start-Class</code> 配置项，，获得我们设置的 Spring Boot 的<strong>主</strong>启动类。</p>
<h5 id="createmainmethodrunner"><strong>createMainMethodRunner</strong></h5>
<pre><code class="language-java">protected MainMethodRunner createMainMethodRunner(String mainClass, String[] args,
			ClassLoader classLoader) {
		return new MainMethodRunner(mainClass, args);
	}
</code></pre>
<h5 id="run">run()</h5>
<pre><code class="language-java">public void run() throws Exception {
    // &lt;1&gt; 加载 Spring Boot
   Class&lt;?&gt; mainClass = Thread.currentThread().getContextClassLoader()
         .loadClass(this.mainClassName);
  // &lt;2&gt; 反射调用 main 方法
   Method mainMethod = mainClass.getDeclaredMethod(&quot;main&quot;, String[].class);
   mainMethod.invoke(null, new Object[] { this.args });
}
</code></pre>
<p>该方法负责最终的 Spring Boot 应用真正的<strong>启动</strong>。</p>
<h3 id="springboot自定义的类加载器-launchedurlclassloader">SpringBoot自定义的类加载器： <strong>LaunchedURLClassLoader</strong></h3>
<p>LaunchedURLClassLoader 是 <code>spring-boot-loader</code> 项目自定义的<strong>类加载器</strong>，实现对 <code>jar</code> 包中 <code>META-INF/classes</code> 目录下的<strong>类</strong>和 <code>META-INF/lib</code> 内嵌的 <code>jar</code> 包中的<strong>类</strong>的<strong>加载</strong>。</p>
<p>该ClassLoader继承自UrlClassLoader。UrlClassLoader加载class就是依靠初始参数传入的Url数组，并且尝试从Url指向的资源中加载Class文件</p>
<pre><code class="language-java">//LaunchedURLClassLoader.java

protected Class&lt;?&gt; loadClass(String name, boolean resolve)
      throws ClassNotFoundException {
   Handler.setUseFastConnectionExceptions(true);
   try {
      try {
          //尝试根据类名去定义类所在的包，即java.lang.Package，确保jar in jar里匹配的manifest能够和关联的package关联起来
         definePackageIfNecessary(name);
      }
      catch (IllegalArgumentException ex) {
         // Tolerate race condition due to being parallel capable
         if (getPackage(name) == null) {
            // This should never happen as the IllegalArgumentException indicates
            // that the package has already been defined and, therefore,
            // getPackage(name) should not return null.

            //这里异常表明，definePackageIfNecessary方法的作用实际上是预先过滤掉查找不到的包
            throw new AssertionError(&quot;Package &quot; + name + &quot; has already been &quot;
                  + &quot;defined but it could not be found&quot;);
         }
      }
      return super.loadClass(name, resolve);
   }
   finally {
      Handler.setUseFastConnectionExceptions(false);
   }
}
</code></pre>
<p>方法super.loadClass(name, resolve)实际上会回到了java.lang.ClassLoader#loadClass(java.lang.String, boolean)，遵循双亲委派机制进行查找类，而Bootstrap ClassLoader和Extension ClassLoader将会查找不到fat jar依赖的类，最终会来到Application ClassLoader，调用java.net.URLClassLoader#findClass</p>
<h2 id="总结">总结</h2>
<ul>
<li>SpringBoot通过扩展JarFile、JarURLConnection及URLStreamHandler，实现了jar in jar中资源的加载</li>
<li>SpringBoot通过扩展URLClassLoader--LauncherURLClassLoader，实现了jar in jar中class文件的加载</li>
<li>JarLauncher通过加载BOOT-INF/classes目录及BOOT-INF/lib目录下jar文件，实现了fat jar的启动</li>
<li>WarLauncher通过加载WEB-INF/classes目录及WEB-INF/lib和WEB-INF/lib-provided目录下的jar文件，实现了war文件的直接启动及web容器中的启动</li>
</ul>
]]></content>
    </entry>
    <entry>
        <title type="html"><![CDATA[Hello Gridea]]></title>
        <id>https://https://github.com/IdeasYH/IdeasYH.github.io/post/hello-gridea/</id>
        <link href="https://https://github.com/IdeasYH/IdeasYH.github.io/post/hello-gridea/">
        </link>
        <updated>2018-12-11T16:00:00.000Z</updated>
        <summary type="html"><![CDATA[<p>👏  欢迎使用 <strong>Gridea</strong> ！<br>
✍️  <strong>Gridea</strong> 一个静态博客写作客户端。你可以用它来记录你的生活、心情、知识、笔记、创意... ...</p>
]]></summary>
        <content type="html"><![CDATA[<p>👏  欢迎使用 <strong>Gridea</strong> ！<br>
✍️  <strong>Gridea</strong> 一个静态博客写作客户端。你可以用它来记录你的生活、心情、知识、笔记、创意... ...</p>
<!-- more -->
<p><a href="https://github.com/getgridea/gridea">Github</a><br>
<a href="https://gridea.dev/">Gridea 主页</a><br>
<a href="http://fehey.com/">示例网站</a></p>
<h2 id="特性">特性👇</h2>
<p>📝  你可以使用最酷的 <strong>Markdown</strong> 语法，进行快速创作</p>
<p>🌉  你可以给文章配上精美的封面图和在文章任意位置插入图片</p>
<p>🏷️  你可以对文章进行标签分组</p>
<p>📋  你可以自定义菜单，甚至可以创建外部链接菜单</p>
<p>💻  你可以在 <strong>Windows</strong>，<strong>MacOS</strong> 或 <strong>Linux</strong> 设备上使用此客户端</p>
<p>🌎  你可以使用 <strong>𝖦𝗂𝗍𝗁𝗎𝖻 𝖯𝖺𝗀𝖾𝗌</strong> 或 <strong>Coding Pages</strong> 向世界展示，未来将支持更多平台</p>
<p>💬  你可以进行简单的配置，接入 <a href="https://github.com/gitalk/gitalk">Gitalk</a> 或 <a href="https://github.com/SukkaW/DisqusJS">DisqusJS</a> 评论系统</p>
<p>🇬🇧  你可以使用<strong>中文简体</strong>或<strong>英语</strong></p>
<p>🌁  你可以任意使用应用内默认主题或任意第三方主题，强大的主题自定义能力</p>
<p>🖥  你可以自定义源文件夹，利用 OneDrive、百度网盘、iCloud、Dropbox 等进行多设备同步</p>
<p>🌱 当然 <strong>Gridea</strong> 还很年轻，有很多不足，但请相信，它会不停向前 🏃</p>
<p>未来，它一定会成为你离不开的伙伴</p>
<p>尽情发挥你的才华吧！</p>
<p>😘 Enjoy~</p>
]]></content>
    </entry>
</feed>