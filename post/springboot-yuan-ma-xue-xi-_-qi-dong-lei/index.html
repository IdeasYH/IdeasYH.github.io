<html>
  <head>
    <meta charset="utf-8" />
<meta name="viewport" content="width=device-width, initial-scale=1" />
<title>Springboot源码学习_启动类 | Gridea</title>
<link rel="shortcut icon" href="https://https://github.com/IdeasYH/IdeasYH.github.io/favicon.ico?v=1603698929878">
<link href="https://cdn.jsdelivr.net/npm/remixicon@2.3.0/fonts/remixicon.css" rel="stylesheet">
<link rel="stylesheet" href="https://https://github.com/IdeasYH/IdeasYH.github.io/styles/main.css">
<link rel="alternate" type="application/atom+xml" title="Springboot源码学习_启动类 | Gridea - Atom Feed" href="https://https://github.com/IdeasYH/IdeasYH.github.io/atom.xml">
<link rel="stylesheet" href="https://fonts.googleapis.com/css?family=Droid+Serif:400,700">



    <meta name="description" content="关于启动类jarLuncher
概述
SpringBoot生成的jar包
​	当使用java -jar命令执行Spring Boot应用的可执行jar文件时，该命令引导标准可执行的jar文件，通过在jar中MANIFES.MF找到Main-..." />
    <meta name="keywords" content="" />
    <link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/KaTeX/0.10.0/katex.min.css">
    <script src="https://cdn.bootcss.com/highlight.js/9.12.0/highlight.min.js"></script>
  </head>
  <body>
    <div class="main">
      <div class="main-content">
        <div class="site-header">
  <a href="https://https://github.com/IdeasYH/IdeasYH.github.io">
  <img class="avatar" src="https://https://github.com/IdeasYH/IdeasYH.github.io/images/avatar.png?v=1603698929878" alt="">
  </a>
  <h1 class="site-title">
    Gridea
  </h1>
  <p class="site-description">
    温故而知新
  </p>
  <div class="menu-container">
    
      
        <a href="/" class="menu">
          首页
        </a>
      
    
      
        <a href="/archives" class="menu">
          归档
        </a>
      
    
      
        <a href="/tags" class="menu">
          标签
        </a>
      
    
      
        <a href="/post/about" class="menu">
          关于
        </a>
      
    
  </div>
  <div class="social-container">
    
      
    
      
    
      
    
      
    
      
    
  </div>
</div>

        <div class="post-detail">
          <article class="post">
            <h2 class="post-title">
              Springboot源码学习_启动类
            </h2>
            <div class="post-info">
              <span>
                2020-10-24
              </span>
              <span>
                20 min read
              </span>
              
            </div>
            
            <div class="post-content-wrapper">
              <div class="post-content">
                <h1 id="关于启动类jarluncher">关于启动类jarLuncher</h1>
<h5 id="概述">概述</h5>
<p>SpringBoot生成的jar包</p>
<p>​	当使用java -jar命令执行Spring Boot应用的可执行jar文件时，该命令引导标准可执行的jar文件，通过在jar中<code>MANIFES.MF</code>找到<code>Main-Class</code>，以<code>JarLauncher.java</code>为入口，加载所有的需要的启动资源（<code>BOOT-INF/classes/*，BOOT-INF/lib/*</code>），交给自定义的类加载器，然后通过反射，启动<code>MANIFES.MF</code>中定义的<code>Start-Class</code>的<code>main()</code>方法，即应用启动类的<code>main()</code>方法。</p>
<p>​	SpringBoot 的可执行jar包又称fat jar ，是包含所有依赖的 jar 包，jar 包中嵌入了除 java 虚拟机以外的所有依赖，是一个 all-in-one jar 包。普通插件maven-jar-plugin生成的包和spring-boot-maven-plugin生成的包之间的直接区别，是fat jar中主要增加了两部分，第一部分是lib目录，存放的是Maven依赖的jar包文件,第二部分是spring boot loader相关的类。</p>
<p>​	<font color = "ff0000">但是系统自带的AppClassLoarder不支持读取嵌套jar包,引入自定义类加载器就是为了能解决jar包嵌套jar包的问题,于是springboot将自定义的类加载器放在最顶成目录,使它可以被加载.</font></p>
<img src="C:\Users\idea\AppData\Roaming\Typora\typora-user-images\image-20201024110331302.png" alt="image-20201024110331302" style="zoom: 67%;" />
<h5 id="为什么springboot要将loader-类下的所有文件复制出来呢">为什么SpringBoot要将Loader 类下的所有文件复制出来呢</h5>
<p>如果将SpringBoot Class Loader 也放到lib文件下，是根本无法被加载到的，因为它根本不符合jar文件的一个标准规范.</p>
<p>程序要有一个启动入口，这个入口要由应用类加载器加载，先将SpringBoot Class Loader加载到内存中，然后通过后续的一些操作创建线程上下文加载器，去加载第三方jar。</p>
<h2 id="1-maven">1 Maven</h2>
<p>也就是说想要知道<code>fat jar</code>是如何生成的，就必须知道<code>spring-boot-maven-plugin</code>工作机制，而<code>spring-boot-maven-plugin</code>属于自定义插件，因此我们又必须知道，<strong>Maven的自定义插件是如何工作的</strong></p>
<h5 id="maven的自定义插件">Maven的自定义插件</h5>
<p>Maven 拥有三套相互独立的生命周期: <strong>clean</strong>、<strong>default</strong> 和 <strong>site</strong>, 而每个生命周期包含一些<strong>phase</strong>阶段, 阶段是有顺序的, 并且后面的阶段依赖于前面的阶段。生命周期的阶段<strong>phase</strong>与插件的目标<strong>goal</strong>相互绑定，用以完成实际的构建任务。</p>
<pre><code class="language-xml">&lt;plugin&gt;
    &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt;
    &lt;artifactId&gt;spring-boot-maven-plugin&lt;/artifactId&gt;
    &lt;executions&gt;
        &lt;execution&gt;
            &lt;goals&gt;
                &lt;goal&gt;repackage&lt;/goal&gt;
            &lt;/goals&gt;
        &lt;/execution&gt;
    &lt;/executions&gt;
&lt;/plugin&gt;
</code></pre>
<p><code>repackage</code>目标对应的将执行到<code>org.springframework.boot.maven.RepackageMojo#execute</code>，该方法的主要逻辑是调用了<code>org.springframework.boot.maven.RepackageMojo#repackage</code></p>
<pre><code class="language-Java">private void repackage() throws MojoExecutionException {
     //获取使用maven-jar-plugin生成的jar，最终的命名将加上.orignal后缀
   Artifact source = getSourceArtifact();
    //最终文件，即Fat jar
   File target = getTargetFile();
    //获取重新打包器，将重新打包成可执行jar文件
   Repackager repackager = getRepackager(source.getFile());
    //查找并过滤项目运行时依赖的jar
   Set&lt;Artifact&gt; artifacts = filterDependencies(this.project.getArtifacts(),
         getFilters(getAdditionalFilters()));
    //将artifacts转换成libraries
   Libraries libraries = new ArtifactsLibraries(artifacts, this.requiresUnpack,
         getLog());
   try {
       //提供Spring Boot启动脚本
      LaunchScript launchScript = getLaunchScript();
       //执行重新打包逻辑，生成最后fat jar
      repackager.repackage(target, libraries, launchScript);
   }
   catch (IOException ex) {
      throw new MojoExecutionException(ex.getMessage(), ex);
   }
    //将source更新成 xxx.jar.orignal文件
   updateArtifact(source, target, repackager.getBackupFile());
}
</code></pre>
<p>我们关心一下<code>org.springframework.boot.maven.RepackageMojo#getRepackager</code>这个方法，知道<code>Repackager</code>是如何生成的，也就大致能够推测出内在的打包逻辑。</p>
<pre><code class="language-Java">private Repackager getRepackager(File source) {
   Repackager repackager = new Repackager(source, this.layoutFactory);
   repackager.addMainClassTimeoutWarningListener(
         new LoggingMainClassTimeoutWarningListener());
    //设置main class的名称，如果不指定的话则会查找第一个包含main方法的类，repacke最后将会设置org.springframework.boot.loader.JarLauncher
   repackager.setMainClass(this.mainClass);
   if (this.layout != null) {
      getLog().info(&quot;Layout: &quot; + this.layout);
       //重点关心下layout 最终返回了 org.springframework.boot.loader.tools.Layouts.Jar
      repackager.setLayout(this.layout.layout());
   }
   return repackager;
}
/**
 * Executable JAR layout.
 */
public static class Jar implements RepackagingLayout {
   @Override
   public String getLauncherClassName() {
      return &quot;org.springframework.boot.loader.JarLauncher&quot;;
   }
   @Override
   public String getLibraryDestination(String libraryName, LibraryScope scope) {
      return &quot;BOOT-INF/lib/&quot;;
   }
   @Override
   public String getClassesLocation() {
      return &quot;&quot;;
   }
   @Override
   public String getRepackagedClassesLocation() {
      return &quot;BOOT-INF/classes/&quot;;
   }
   @Override
   public boolean isExecutable() {
      return true;
   }
}
</code></pre>
<p><code>layout</code>我们可以将之翻译为文件布局，或者目录布局，代码一看清晰明了，同时我们需要关注，也是下一个重点关注对象<code>org.springframework.boot.loader.JarLauncher</code>，从名字推断，这很可能是返回可执行<code>jar</code>文件的启动类。</p>
<h5 id="manifestmf文件内容">MANIFEST.MF文件内容</h5>
<pre><code class="language-json">Manifest-Version: 1.0
Start-Class: com.shengsiyuan.boot.MyApplication
Main-Class: org.springframework.boot.loader.JarLauncher
</code></pre>
<p><code>repackager</code>生成的MANIFEST.MF文件为以上信息，可以看到两个关键信息<code>Main-Class</code>和<code>Start-Class</code>。我们可以进一步，程序的启动入口并不是我们SpringBoot中定义的<code>main</code>，而是<code>JarLauncher#main</code>，而再在其中利用反射调用定义好的<code>Start-Class</code>的<code>main</code>方法</p>
<h5 id="jarlauncher">JarLauncher</h5>
<h5 id="重点类介绍">重点类介绍</h5>
<ul>
<li>
<p><code>java.util.jar.JarFile</code> JDK工具类提供的读取<code>jar</code>文件</p>
</li>
<li>
<p><code>org.springframework.boot.loader.jar.JarFile</code>Springboot-loader 继承JDK提供<code>JarFile</code>类</p>
</li>
<li>
<p><code>java.util.jar.JarEntry</code>DK工具类提供的``jar```文件条目</p>
</li>
<li>
<p><code>org.springframework.boot.loader.jar.JarEntry</code> Springboot-loader 继承JDK提供<code>JarEntry</code>类</p>
</li>
<li>
<pre><code>org.springframework.boot.loader.archive.Archive
</code></pre>
<p>Springboot抽象出来的统一访问资源的层</p>
<ul>
<li><code>JarFileArchive</code>jar包文件的抽象</li>
<li><code>ExplodedArchive</code>文件目录</li>
</ul>
</li>
</ul>
<p>这里重点描述一下<code>JarFile</code>的作用，每个<code>JarFileArchive</code>都会对应一个<code>JarFile</code>。在构造的时候会解析内部结构，去获取<code>jar</code>包里的各个<strong>文件</strong>或<strong>文件夹</strong>类。我们可以看一下该类的注释。</p>
<pre><code>/* Extended variant of {@link java.util.jar.JarFile} that behaves in the same way but
* offers the following additional functionality.
* &lt;ul&gt;
* &lt;li&gt;A nested {@link JarFile} can be {@link #getNestedJarFile(ZipEntry) obtained} based
* on any directory entry.&lt;/li&gt;
* &lt;li&gt;A nested {@link JarFile} can be {@link #getNestedJarFile(ZipEntry) obtained} for
* embedded JAR files (as long as their entry is not compressed).&lt;/li&gt;
**/ &lt;/ul&gt;
</code></pre>
<p><code>jar</code>里的资源分隔符是<code>!/</code>，在JDK提供的<code>JarFile</code> URL只支持一个’!/‘，而Spring boot扩展了这个协议，让它支持多个’!/‘，就可以表示jar in jar、jar in directory、fat jar的资源了。</p>
<h5 id="自定义类加载机制">自定义类加载机制</h5>
<ul>
<li>最基础：Bootstrap ClassLoader（加载JDK的/lib目录下的类）</li>
<li>次基础：Extension ClassLoader（加载JDK的/lib/ext目录下的类）</li>
<li>普通：Application ClassLoader（程序自己classpath下的类）</li>
</ul>
<p>首先需要关注<strong>双亲委派机制</strong>很重要的一点是，如果一个类可以被委派最基础的ClassLoader加载，就不能让高层的ClassLoader加载，这样是为了范围错误的引入了非JDK下但是类名一样的类。其二，如果在这个机制下，由于<code>fat jar</code>中依赖的各个<code>jar</code>文件，并不在程序自己<code>classpath</code>下，也就是说，如果我们采用双亲委派机制的话，<strong>根本获取不到我们所依赖的jar包，因此我们需要修改双亲委派机制的查找class的方法，自定义类加载机制</strong>。</p>
<p>先简单的介绍Springboot2中<code>LaunchedURLClassLoader</code>，该类继承了<code>java.net.URLClassLoader</code>,重写了<code>java.lang.ClassLoader#loadClass(java.lang.String, boolean)</code>，然后我们再探讨他是如何修改双亲委派机制。</p>
<p>在上面我们讲到Spring boot支持多个’!/‘以表示多个jar，而我们的问题在于，如何解决查找到这多个jar包。我们看一下<code>LaunchedURLClassLoader</code>的构造方法。</p>
<pre><code class="language-Java">public LaunchedURLClassLoader(URL[] urls, ClassLoader parent) {
   super(urls, parent);
}
</code></pre>
<p><strong><code>urls</code>注释解释道<code>the URLs from which to load classes and resources</code>，即fat jar包依赖的所有类和资源，将该<code>urls</code>参数传递给父类<code>java.net.URLClassLoader</code>，由父类的<code>java.net.URLClassLoader#findClass</code>执行查找类方法，该类的查找来源即构造方法传递进来的urls参数</strong></p>
<pre><code class="language-Java">//LaunchedURLClassLoader的实现
protected Class&lt;?&gt; loadClass(String name, boolean resolve)
      throws ClassNotFoundException {
   Handler.setUseFastConnectionExceptions(true);
   try {
      try {
          //尝试根据类名去定义类所在的包，即java.lang.Package，确保jar in jar里匹配的manifest能够和关联	           //的package关联起来
         definePackageIfNecessary(name);
      }
      catch (IllegalArgumentException ex) {
         // Tolerate race condition due to being parallel capable
         if (getPackage(name) == null) {
            // This should never happen as the IllegalArgumentException indicates
            // that the package has already been defined and, therefore,
            // getPackage(name) should not return null.
             
            //这里异常表明，definePackageIfNecessary方法的作用实际上是预先过滤掉查找不到的包
            throw new AssertionError(&quot;Package &quot; + name + &quot; has already been &quot;
                  + &quot;defined but it could not be found&quot;);
         }
      }
      return super.loadClass(name, resolve);
   }
   finally {
      Handler.setUseFastConnectionExceptions(false);
   }
}
</code></pre>
<p>方法<code>super.loadClass(name, resolve)</code>实际上会回到了<code>java.lang.ClassLoader#loadClass(java.lang.String, boolean)</code>，遵循双亲委派机制进行查找类，而<code>Bootstrap ClassLoader</code>和<code>Extension ClassLoader</code>将会查找不到fat jar依赖的类，最终会来到<code>Application ClassLoader</code>，调用<code>java.net.URLClassLoader#findClass</code></p>
<h5 id="如何真正的启动">如何真正的启动</h5>
<p>Springboot2和Springboot1的最大区别在于，Springboo1会新起一个线程，来执行相应的<strong>反射调用逻辑</strong>，而SpringBoot2则去掉了构建新的线程这一步。方法是<code>org.springframework.boot.loader.Launcher#launch(java.lang.String[], java.lang.String, java.lang.ClassLoader)</code>反射调用逻辑比较简单，这里就不再分析，比较关键的一点是，在调用<code>main</code>方法之前，将当前线程的上下文类加载器设置成<code>LaunchedURLClassLoader</code></p>
<pre><code class="language-Java">protected void launch(String[] args, String mainClass, ClassLoader classLoader)
      throws Exception {
   Thread.currentThread().setContextClassLoader(classLoader);
   createMainMethodRunner(mainClass, args, classLoader).run();
}
</code></pre>
<h5 id="demo">Demo</h5>
<pre><code class="language-Java">public static void main(String[] args) throws ClassNotFoundException, MalformedURLException {
        JarFile.registerUrlProtocolHandler();
// 构造LaunchedURLClassLoader类加载器，这里使用了2个URL，分别对应jar包中依赖包spring-boot-loader和spring-boot，使用 &quot;!/&quot; 分开，需要org.springframework.boot.loader.jar.Handler处理器处理
        LaunchedURLClassLoader classLoader = new LaunchedURLClassLoader(
                new URL[] {
                        new URL(&quot;jar:file:/E:/IdeaProjects/oneday-auth/oneday-auth-server/target/oneday-auth-server-1.0.0-SNAPSHOT.jar!/BOOT-INF/lib/spring-boot-loader-1.2.3.RELEASE.jar!/&quot;)
                        , new URL(&quot;jar:file:/E:/IdeaProjects/oneday-auth/oneday-auth-server/target/oneday-auth-server-1.0.0-SNAPSHOT.jar!/BOOT-INF/lib/spring-boot-2.1.3.RELEASE.jar!/&quot;)
                },
                Application.class.getClassLoader());
// 加载类
// 这2个类都会在第二步本地查找中被找出(URLClassLoader的findClass方法)
        classLoader.loadClass(&quot;org.springframework.boot.loader.JarLauncher&quot;);
        classLoader.loadClass(&quot;org.springframework.boot.SpringApplication&quot;);
// 在第三步使用默认的加载顺序在ApplicationClassLoader中被找出
   classLoader.loadClass(&quot;org.springframework.boot.autoconfigure.web.DispatcherServletAutoConfiguration&quot;);

//        SpringApplication.run(Application.class, args);
    }
</code></pre>
<h2 id="2启动器实现原理">2启动器实现原理</h2>
<p>Launcher的继承关系如下：<br>
<img src="C:\Users\idea\AppData\Roaming\Typora\typora-user-images\image-20201024114850040.png" alt="image-20201024114850040" style="zoom:67%;" /></p>
<h3 id="启动类jarlauncher"><strong>启动类：JarLauncher</strong></h3>
<pre><code class="language-java">//JarLauncher.java
public class JarLauncher extends ExecutableArchiveLauncher {

	static final String BOOT_INF_CLASSES = &quot;BOOT-INF/classes/&quot;;

	static final String BOOT_INF_LIB = &quot;BOOT-INF/lib/&quot;;

	public JarLauncher() {
	}

	protected JarLauncher(Archive archive) {
		super(archive);
	}

	@Override
	protected boolean isNestedArchive(Archive.Entry entry) {
		if (entry.isDirectory()) {
			return entry.getName().equals(BOOT_INF_CLASSES);
		}
		return entry.getName().startsWith(BOOT_INF_LIB);
	}

	public static void main(String[] args) throws Exception {
		new JarLauncher().launch(args);
	}
}
</code></pre>
<p>JarLauncher默认构造函数实现为空，它父类ExecutableArchiveLauncher会调用再上一级父类Launcher的createArchive方法加载jar包, 加载了jar包之后，我们就能获取到里面所有的资源。</p>
<pre><code class="language-java">	//JarLauncher.java
	
	//JarLauncher默认构造函数
	public JarLauncher() {
	}
	
//ExecutableArchiveLauncher.java	

public ExecutableArchiveLauncher() {
		try {
      //开始加载jar包
			this.archive = createArchive();
		}
		catch (Exception ex) {
			throw new IllegalStateException(ex);
		}
	}
//Launcher.java	

protected final Archive createArchive() throws Exception {
    //通过获取当前Class类的信息，查找到当前归档文件的路径
		ProtectionDomain protectionDomain = getClass().getProtectionDomain();
		CodeSource codeSource = protectionDomain.getCodeSource();
		URI location = (codeSource != null) ? codeSource.getLocation().toURI() : null;
		String path = (location != null) ? location.getSchemeSpecificPart() : null;
		if (path == null) {
			throw new IllegalStateException(&quot;Unable to determine code source archive&quot;);
		}
    //获取到路径之后，创建对应的文件，并检查是否存在
		File root = new File(path);
		if (!root.exists()) {
			throw new IllegalStateException(
					&quot;Unable to determine code source archive from &quot; + root);
		}
    //如果是目录，则创建ExplodedArchive，否则创建JarFileArchive
		return (root.isDirectory() ? new ExplodedArchive(root)
				: new JarFileArchive(root));
	}
</code></pre>
<h3 id="核心方法launchstring-args">核心方法：launch(String[] args)</h3>
<p>launch方法实际上是调用父类Launcher的launch方法</p>
<pre><code class="language-java">// Launcher.java	

protected void launch(String[] args) throws Exception {
    //注册 Spring Boot 自定义的 URLStreamHandler 实现类，用于 jar 包的加载读取, 可读取到内嵌的jar包
		JarFile.registerUrlProtocolHandler();
    //创建自定义的 ClassLoader 实现类，用于从 jar 包中加载类。
		ClassLoader classLoader = createClassLoader(getClassPathArchives());
    //执行我们声明的 Spring Boot 启动类，进行 Spring Boot 应用的启动。
		launch(args, getMainClass(), classLoader);
	}
</code></pre>
<p>简单来说，就是创建一个可以读取 <code>jar</code> 包中类的加载器，保证 <code>BOOT-INF/lib</code> 目录下的类和 <code>BOOT-classes</code> 内嵌的 <code>jar</code> 中的类能够被正常加载到，之后执行 Spring Boot 应用的启动。</p>
<h4 id="方法一registerurlprotocolhandler">方法一：<strong>registerUrlProtocolHandler</strong></h4>
<pre><code class="language-java">public static void registerUrlProtocolHandler() {
    	// 获得 URLStreamHandler 的路径
		String handlers = System.getProperty(PROTOCOL_HANDLER, &quot;&quot;);
    	// 将 Spring Boot 自定义的 HANDLERS_PACKAGE(org.springframework.boot.loader) 补充上去
		System.setProperty(PROTOCOL_HANDLER, (&quot;&quot;.equals(handlers) ? HANDLERS_PACKAGE
				: handlers + &quot;|&quot; + HANDLERS_PACKAGE));
    	// 重置已缓存的 URLStreamHandler 处理器们
		resetCachedUrlHandlers();
	}
</code></pre>
<p>该方法的目的就是通过将 <code>org.springframework.boot.loader</code> 包设置到 <code>&quot;java.protocol.handler.pkgs&quot;</code> 环境变量，从而使用到自定义的 URLStreamHandler 实现类 Handler，处理 <code>jar:</code> 协议的 URL。</p>
<pre><code>利用java url协议实现扩展原理，自定义jar协议
将org.springframework.boot.loader包 追加到java系统 属性java.protocol.handler.pkgs中，实现自定义jar协议

java会在java.protocol.handler.pkgs系统属性指定的包中查找与协议同名的子包和名为Handler的类，
即负责处理当前协议的URLStreamHandler实现类必须在 &lt;包名&gt;.&lt;协议名定义的包&gt; 中，并且类名称必须为Handler
例如：
org.springframework.boot.loader.jar.Handler这个类 将用于处理jar协议

这个jar协议实现作用：
默认情况下，JDK提供的ClassLoader只能识别jar中的class文件以及加载classpath下的其他jar包中的class文件。
对于jar包中的jar包是无法加载的
所以spring boot 自己定义了一套URLStreamHandler实现类和JarURLConnection实现类，用来加载jar包中的jar包的class类文件
</code></pre>
<p>举个例子：</p>
<pre><code>jar:file:C:/Users/Administrator/Desktop/demo/demo/target/jarlauncher-0.0.1-SNAPSHOT.jar!/lib/spring-boot-1.5.10.RELEASE.jar!/

jar:file:C:/Users/Administrator/Desktop/demo/demo/target/jarlauncher-0.0.1-SNAPSHOT.jar!/lib/spring-boot-1.5.10.RELEASE.jar!/org/springframework/boot/loader/JarLauncher.class
123
</code></pre>
<p>我们看到如果有 jar 包中包含 jar，或者 jar 包中包含 jar 包里面的 class 文件，那么会使用 !/分隔开，这种方式只有 org.springframework.boot.loader.jar.Handler 能处理，它是 SpringBoot 内部扩展出来一种<strong>URL协议</strong>.</p>
<p>通常，jar里的资源分隔符是!/，在JDK提供的JarFile URL只支持一层“!/”，而Spring Boot扩展了该协议，可支持多层“!/”。</p>
<h4 id="方法二createclassloader">方法二：<strong>createClassLoader</strong></h4>
<pre><code class="language-java">ClassLoader classLoader = createClassLoader(getClassPathArchives());
</code></pre>
<h5 id="getclasspatharchives">getClassPathArchives（）</h5>
<pre><code class="language-java">// ExecutableArchiveLauncher.java

@Override
protected List&lt;Archive&gt; getClassPathArchives() throws Exception {
 // &lt;1&gt; 获得所有 Archive
 List&lt;Archive&gt; archives = new ArrayList&lt;&gt;(
   this.archive.getNestedArchives(this::isNestedArchive));
 // &lt;2&gt; 后续处理：是个空方法
 postProcessClassPathArchives(archives);
 return archives;
}
</code></pre>
<p><code>&lt;1&gt;</code> 处，<code>this::isNestedArchive</code> 代码段，创建了 EntryFilter 匿名实现类，用于过滤 <code>jar</code> 包不需要的目录。目的就是过滤获得，<code>BOOT-INF/classes/</code> 目录下的类，以及 <code>BOOT-INF/lib/</code> 的内嵌 <code>jar</code> 包。</p>
<pre><code class="language-java">// JarLauncher.java

static final String BOOT_INF_CLASSES = &quot;BOOT-INF/classes/&quot;;

static final String BOOT_INF_LIB = &quot;BOOT-INF/lib/&quot;;

@Override
protected boolean isNestedArchive(Archive.Entry entry) {
    // 如果是目录的情况，只要 BOOT-INF/classes/ 目录
 if (entry.isDirectory()) {
  return entry.getName().equals(BOOT_INF_CLASSES);
 }
 // 如果是文件的情况，只要 BOOT-INF/lib/ 目录下的 `jar` 包
 return entry.getName().startsWith(BOOT_INF_LIB);
}
</code></pre>
<p>&lt;1&gt;处getNestedArchives()方法实现</p>
<pre><code class="language-java">	//JarFileArchive.java
	
	@Override
	public List&lt;Archive&gt; getNestedArchives(EntryFilter filter) throws IOException {
		List&lt;Archive&gt; nestedArchives = new ArrayList&lt;&gt;();
		for (Entry entry : this) {
			if (filter.matches(entry)) {
				nestedArchives.add(getNestedArchive(entry));
			}
		}
		return Collections.unmodifiableList(nestedArchives);
	}
</code></pre>
<h5 id="createclassloaderlist-archives">createClassLoader(List archives)</h5>
<pre><code class="language-java">// ExecutableArchiveLauncher.java

protected ClassLoader createClassLoader(List&lt;Archive&gt; archives) throws Exception {
 // 获得所有 Archive 的 URL 地址
    List&lt;URL&gt; urls = new ArrayList&lt;&gt;(archives.size());
 for (Archive archive : archives) {
  urls.add(archive.getUrl());
 }
 // 创建加载这些 URL 的 ClassLoader
 return createClassLoader(urls.toArray(new URL[0]));
}

protected ClassLoader createClassLoader(URL[] urls) throws Exception {
 return new LaunchedURLClassLoader(urls, getClass().getClassLoader());
}
</code></pre>
<p>基于获得的 Archive 数组，创建自定义 ClassLoader 实现类 LaunchedURLClassLoader，通过它来加载 <code>BOOT-INF/classes</code> 目录下的类，以及 <code>BOOT-INF/lib</code> 目录下的 <code>jar</code> 包中的类。</p>
<h4 id="方法三launchstring-args-string-mainclass-classloader-classloader">方法三：launch(String[] args, String mainClass, ClassLoader classLoader)</h4>
<p>给定存档文件和完全配置的类加载器，启动应用程序。</p>
<pre><code class="language-java">launch(args, getMainClass(), classLoader);
protected void launch(String[] args, String mainClass, ClassLoader classLoader)
			throws Exception {
    	  // &lt;1&gt; 设置 LaunchedURLClassLoader 作为类加载器
		Thread.currentThread().setContextClassLoader(classLoader);
    	 // &lt;2&gt; 创建 MainMethodRunner 对象，并执行 run 方法，启动 Spring Boot 应用
		createMainMethodRunner(mainClass, args, classLoader).run();
	}
</code></pre>
<p><code>&lt;1&gt;</code> 处：设置 LaunchedURLClassLoader 作为类加载器，从而保证能够从 <code>jar</code> 包中加载到相应的类。</p>
<h5 id="getmainclass"><strong>getMainClass()</strong></h5>
<pre><code class="language-java">// ExecutableArchiveLauncher.java

@Override
protected String getMainClass() throws Exception {
    // 获得启动的类的全名
 Manifest manifest = this.archive.getManifest();
 String mainClass = null;
 if (manifest != null) {
  mainClass = manifest.getMainAttributes().getValue(&quot;Start-Class&quot;);
 }
 if (mainClass == null) {
  throw new IllegalStateException(
    &quot;No 'Start-Class' manifest entry specified in &quot; + this);
 }
 return mainClass;
}
</code></pre>
<p>从 <code>jar</code> 包的 <code>MANIFEST.MF</code> 文件的 <code>Start-Class</code> 配置项，，获得我们设置的 Spring Boot 的<strong>主</strong>启动类。</p>
<h5 id="createmainmethodrunner"><strong>createMainMethodRunner</strong></h5>
<pre><code class="language-java">protected MainMethodRunner createMainMethodRunner(String mainClass, String[] args,
			ClassLoader classLoader) {
		return new MainMethodRunner(mainClass, args);
	}
</code></pre>
<h5 id="run">run()</h5>
<pre><code class="language-java">public void run() throws Exception {
    // &lt;1&gt; 加载 Spring Boot
   Class&lt;?&gt; mainClass = Thread.currentThread().getContextClassLoader()
         .loadClass(this.mainClassName);
  // &lt;2&gt; 反射调用 main 方法
   Method mainMethod = mainClass.getDeclaredMethod(&quot;main&quot;, String[].class);
   mainMethod.invoke(null, new Object[] { this.args });
}
</code></pre>
<p>该方法负责最终的 Spring Boot 应用真正的<strong>启动</strong>。</p>
<h3 id="springboot自定义的类加载器-launchedurlclassloader">SpringBoot自定义的类加载器： <strong>LaunchedURLClassLoader</strong></h3>
<p>LaunchedURLClassLoader 是 <code>spring-boot-loader</code> 项目自定义的<strong>类加载器</strong>，实现对 <code>jar</code> 包中 <code>META-INF/classes</code> 目录下的<strong>类</strong>和 <code>META-INF/lib</code> 内嵌的 <code>jar</code> 包中的<strong>类</strong>的<strong>加载</strong>。</p>
<p>该ClassLoader继承自UrlClassLoader。UrlClassLoader加载class就是依靠初始参数传入的Url数组，并且尝试从Url指向的资源中加载Class文件</p>
<pre><code class="language-java">//LaunchedURLClassLoader.java

protected Class&lt;?&gt; loadClass(String name, boolean resolve)
      throws ClassNotFoundException {
   Handler.setUseFastConnectionExceptions(true);
   try {
      try {
          //尝试根据类名去定义类所在的包，即java.lang.Package，确保jar in jar里匹配的manifest能够和关联的package关联起来
         definePackageIfNecessary(name);
      }
      catch (IllegalArgumentException ex) {
         // Tolerate race condition due to being parallel capable
         if (getPackage(name) == null) {
            // This should never happen as the IllegalArgumentException indicates
            // that the package has already been defined and, therefore,
            // getPackage(name) should not return null.

            //这里异常表明，definePackageIfNecessary方法的作用实际上是预先过滤掉查找不到的包
            throw new AssertionError(&quot;Package &quot; + name + &quot; has already been &quot;
                  + &quot;defined but it could not be found&quot;);
         }
      }
      return super.loadClass(name, resolve);
   }
   finally {
      Handler.setUseFastConnectionExceptions(false);
   }
}
</code></pre>
<p>方法super.loadClass(name, resolve)实际上会回到了java.lang.ClassLoader#loadClass(java.lang.String, boolean)，遵循双亲委派机制进行查找类，而Bootstrap ClassLoader和Extension ClassLoader将会查找不到fat jar依赖的类，最终会来到Application ClassLoader，调用java.net.URLClassLoader#findClass</p>
<h2 id="总结">总结</h2>
<ul>
<li>SpringBoot通过扩展JarFile、JarURLConnection及URLStreamHandler，实现了jar in jar中资源的加载</li>
<li>SpringBoot通过扩展URLClassLoader--LauncherURLClassLoader，实现了jar in jar中class文件的加载</li>
<li>JarLauncher通过加载BOOT-INF/classes目录及BOOT-INF/lib目录下jar文件，实现了fat jar的启动</li>
<li>WarLauncher通过加载WEB-INF/classes目录及WEB-INF/lib和WEB-INF/lib-provided目录下的jar文件，实现了war文件的直接启动及web容器中的启动</li>
</ul>

              </div>
              <div class="toc-container">
                <ul class="markdownIt-TOC">
<li><a href="#%E5%85%B3%E4%BA%8E%E5%90%AF%E5%8A%A8%E7%B1%BBjarluncher">关于启动类jarLuncher</a><br>
*<br>
*<br>
*<br>
* <a href="#%E6%A6%82%E8%BF%B0">概述</a><br>
* <a href="#%E4%B8%BA%E4%BB%80%E4%B9%88springboot%E8%A6%81%E5%B0%86loader-%E7%B1%BB%E4%B8%8B%E7%9A%84%E6%89%80%E6%9C%89%E6%96%87%E4%BB%B6%E5%A4%8D%E5%88%B6%E5%87%BA%E6%9D%A5%E5%91%A2">为什么SpringBoot要将Loader 类下的所有文件复制出来呢</a>
<ul>
<li><a href="#1-maven">1 Maven</a><br>
*<br>
*<br>
* <a href="#maven%E7%9A%84%E8%87%AA%E5%AE%9A%E4%B9%89%E6%8F%92%E4%BB%B6">Maven的自定义插件</a><br>
* <a href="#manifestmf%E6%96%87%E4%BB%B6%E5%86%85%E5%AE%B9">MANIFEST.MF文件内容</a><br>
* <a href="#jarlauncher">JarLauncher</a><br>
* <a href="#%E9%87%8D%E7%82%B9%E7%B1%BB%E4%BB%8B%E7%BB%8D">重点类介绍</a><br>
* <a href="#%E8%87%AA%E5%AE%9A%E4%B9%89%E7%B1%BB%E5%8A%A0%E8%BD%BD%E6%9C%BA%E5%88%B6">自定义类加载机制</a><br>
* <a href="#%E5%A6%82%E4%BD%95%E7%9C%9F%E6%AD%A3%E7%9A%84%E5%90%AF%E5%8A%A8">如何真正的启动</a><br>
* <a href="#demo">Demo</a></li>
<li><a href="#2%E5%90%AF%E5%8A%A8%E5%99%A8%E5%AE%9E%E7%8E%B0%E5%8E%9F%E7%90%86">2启动器实现原理</a>
<ul>
<li><a href="#%E5%90%AF%E5%8A%A8%E7%B1%BBjarlauncher"><strong>启动类：JarLauncher</strong></a></li>
<li><a href="#%E6%A0%B8%E5%BF%83%E6%96%B9%E6%B3%95launchstring-args">核心方法：launch(String[] args)</a>
<ul>
<li><a href="#%E6%96%B9%E6%B3%95%E4%B8%80registerurlprotocolhandler">方法一：<strong>registerUrlProtocolHandler</strong></a></li>
<li><a href="#%E6%96%B9%E6%B3%95%E4%BA%8Ccreateclassloader">方法二：<strong>createClassLoader</strong></a>
<ul>
<li><a href="#getclasspatharchives">getClassPathArchives（）</a></li>
<li><a href="#createclassloaderlist-archives">createClassLoader(List archives)</a></li>
</ul>
</li>
<li><a href="#%E6%96%B9%E6%B3%95%E4%B8%89launchstring-args-string-mainclass-classloader-classloader">方法三：launch(String[] args, String mainClass, ClassLoader classLoader)</a>
<ul>
<li><a href="#getmainclass"><strong>getMainClass()</strong></a></li>
<li><a href="#createmainmethodrunner"><strong>createMainMethodRunner</strong></a></li>
<li><a href="#run">run()</a></li>
</ul>
</li>
</ul>
</li>
<li><a href="#springboot%E8%87%AA%E5%AE%9A%E4%B9%89%E7%9A%84%E7%B1%BB%E5%8A%A0%E8%BD%BD%E5%99%A8-launchedurlclassloader">SpringBoot自定义的类加载器： <strong>LaunchedURLClassLoader</strong></a></li>
</ul>
</li>
<li><a href="#%E6%80%BB%E7%BB%93">总结</a></li>
</ul>
</li>
</ul>

              </div>
            </div>
          </article>
        </div>

        
          <div class="next-post">
            <div class="next">下一篇</div>
            <a href="https://https://github.com/IdeasYH/IdeasYH.github.io/post/hello-gridea/">
              <h3 class="post-title">
                Hello Gridea
              </h3>
            </a>
          </div>
        

        

        <div class="site-footer">
  Powered by <a href="https://github.com/getgridea/gridea" target="_blank">Gridea</a>
  <a class="rss" href="https://https://github.com/IdeasYH/IdeasYH.github.io/atom.xml" target="_blank">
    <i class="ri-rss-line"></i> RSS
  </a>
</div>

      </div>
    </div>

    <script>
      hljs.initHighlightingOnLoad()

      let mainNavLinks = document.querySelectorAll(".markdownIt-TOC a");

      // This should probably be throttled.
      // Especially because it triggers during smooth scrolling.
      // https://lodash.com/docs/4.17.10#throttle
      // You could do like...
      // window.addEventListener("scroll", () => {
      //    _.throttle(doThatStuff, 100);
      // });
      // Only not doing it here to keep this Pen dependency-free.

      window.addEventListener("scroll", event => {
        let fromTop = window.scrollY;

        mainNavLinks.forEach((link, index) => {
          let section = document.getElementById(decodeURI(link.hash).substring(1));
          let nextSection = null
          if (mainNavLinks[index + 1]) {
            nextSection = document.getElementById(decodeURI(mainNavLinks[index + 1].hash).substring(1));
          }
          if (section.offsetTop <= fromTop) {
            if (nextSection) {
              if (nextSection.offsetTop > fromTop) {
                link.classList.add("current");
              } else {
                link.classList.remove("current");    
              }
            } else {
              link.classList.add("current");
            }
          } else {
            link.classList.remove("current");
          }
        });
      });

    </script>
  </body>
</html>
